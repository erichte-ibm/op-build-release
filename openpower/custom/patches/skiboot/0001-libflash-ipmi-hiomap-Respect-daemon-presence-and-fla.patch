From e56777fbd8503a8f2583f74ba0a40b14dd4d52ba Mon Sep 17 00:00:00 2001
From: Andrew Jeffery <andrew@aj.id.au>
Date: Mon, 5 Nov 2018 16:06:19 +1030
Subject: [PATCH] libflash/ipmi-hiomap: Respect daemon presence and flash
 control

Add a series of unit tests to exercise the hiomap event handling code.
In the process, fix the fix of ORing in the BMC state - we only want to
retain state covered by the ack mask as this is something we still need
to handle. Critically, we must not retain state not covered by the ack
mask as this may lead to host firmware attempting to communicate with a
dead daemon or attempting to access the PNOR whilst the daemon is not in
control of the flash.

Fixes: 34cffed2ccf3 ("libflash/ipmi-hiomap: Improve event handling")
Signed-off-by: Andrew Jeffery <andrew@aj.id.au>
---
 libflash/ipmi-hiomap.c           |   4 +-
 libflash/test/Makefile.check     |   2 +-
 libflash/test/test-ipmi-hiomap.c | 327 +++++++++++++++++++++++++++++++
 3 files changed, 330 insertions(+), 3 deletions(-)
 create mode 100644 libflash/test/test-ipmi-hiomap.c

diff --git a/libflash/ipmi-hiomap.c b/libflash/ipmi-hiomap.c
index 850fb3da338a..9aee0290ce38 100644
--- a/libflash/ipmi-hiomap.c
+++ b/libflash/ipmi-hiomap.c
@@ -318,7 +318,7 @@ static bool hiomap_window_move(struct ipmi_hiomap *ctx, uint8_t command,
 		*size = (ctx->current.cur_pos + ctx->current.size) - pos;
 
 	if (len != 0 && *size == 0) {
-		prerror("Invalid window properties: len: %llu, size: %llu\n",
+		prerror("Invalid window properties: len: %"PRIu64", size: %"PRIu64"\n",
 			len, *size);
 		return false;
 	}
@@ -476,7 +476,7 @@ static void hiomap_event(uint8_t events, void *context)
 	prlog(PR_DEBUG, "Received events: 0x%x\n", events);
 
 	lock(&ctx->lock);
-	ctx->bmc_state |= events;
+	ctx->bmc_state = events | (ctx->bmc_state & HIOMAP_E_ACK_MASK);
 	ctx->update = true;
 	unlock(&ctx->lock);
 }
diff --git a/libflash/test/Makefile.check b/libflash/test/Makefile.check
index f4ad96ef25b1..bbe3377c33f6 100644
--- a/libflash/test/Makefile.check
+++ b/libflash/test/Makefile.check
@@ -1,7 +1,7 @@
 # -*-Makefile-*-
 TEST_FLAGS = -D__TEST__
 
-LIBFLASH_TEST := libflash/test/test-flash libflash/test/test-ecc libflash/test/test-blocklevel libflash/test/test-mbox
+LIBFLASH_TEST := libflash/test/test-flash libflash/test/test-ecc libflash/test/test-blocklevel libflash/test/test-mbox libflash/test/test-ipmi-hiomap
 
 LCOV_EXCLUDE += $(LIBFLASH_TEST:%=%.c)
 
diff --git a/libflash/test/test-ipmi-hiomap.c b/libflash/test/test-ipmi-hiomap.c
new file mode 100644
index 000000000000..0bac90f8940d
--- /dev/null
+++ b/libflash/test/test-ipmi-hiomap.c
@@ -0,0 +1,327 @@
+#include <assert.h>
+#include <ccan/container_of/container_of.h>
+#include <lock.h>
+#include <hiomap.h>
+#include <ipmi.h>
+#include <platform.h>
+#include <stdio.h>
+#include <stdlib.h>
+
+/* Yarrrh */
+#define zalloc(x) calloc(1, x)
+#undef lock
+#define lock(x)
+#define unlock(x)
+
+const struct bmc_sw_config bmc_sw_hiomap = {
+	.ipmi_oem_hiomap_cmd         = IPMI_CODE(0x3a, 0x5a),
+};
+
+const struct bmc_platform _bmc_platform = {
+	.name = "generic:hiomap",
+	.sw = &bmc_sw_hiomap,
+};
+
+enum scenario_event_type {
+	scenario_sentinal = 0,
+	scenario_event_p,
+	scenario_cmd,
+	scenario_sel
+};
+
+struct scenario_cmd_data {
+	uint8_t cmd;
+	uint8_t seq;
+	uint8_t args[13];
+} __attribute__((packed));
+
+struct scenario_cmd {
+	struct scenario_cmd_data req;
+	struct scenario_cmd_data resp;
+	uint8_t cc;
+};
+
+struct scenario_sel {
+	uint8_t bmc_state;
+};
+
+struct scenario_event {
+	enum scenario_event_type type;
+	union {
+		const struct scenario_event *p;
+		struct scenario_cmd c;
+		struct scenario_sel s;
+	};
+};
+
+struct ipmi_sel {
+	void (*fn)(uint8_t data, void *context);
+	void *context;
+};
+
+struct ipmi_msg_ctx {
+	const struct scenario_event *scenario;
+	const struct scenario_event *cursor;
+
+	struct ipmi_sel sel;
+
+	struct ipmi_msg msg;
+};
+
+struct ipmi_msg_ctx ipmi_msg_ctx;
+
+const struct bmc_platform *bmc_platform = &_bmc_platform;
+
+static void scenario_init(const struct scenario_event *scenario)
+{
+	ipmi_msg_ctx.scenario = scenario;
+	ipmi_msg_ctx.cursor = scenario;
+}
+
+void ipmi_init_msg(struct ipmi_msg *msg, int interface __attribute__((unused)),
+		   uint32_t code, void (*complete)(struct ipmi_msg *),
+		   void *user_data, size_t req_size, size_t resp_size)
+{
+	msg->backend = NULL;
+	msg->cmd = IPMI_CMD(code);
+	msg->netfn = IPMI_NETFN(code) << 2;
+	msg->req_size = req_size;
+	msg->resp_size = resp_size;
+	msg->complete = complete;
+	msg->user_data = user_data;
+}
+
+struct ipmi_msg *ipmi_mkmsg(int interface __attribute__((unused)),
+			    uint32_t code, void (*complete)(struct ipmi_msg *),
+			    void *user_data, void *req_data, size_t req_size,
+			    size_t resp_size)
+{
+	struct ipmi_msg *msg = &ipmi_msg_ctx.msg;
+
+	ipmi_init_msg(msg, 0 /* some bogus value */, code, complete, user_data,
+		      req_size, resp_size);
+
+	msg->data = malloc(req_size > resp_size ? req_size : resp_size);
+	if (req_data)
+		memcpy(msg->data, req_data, req_size);
+
+	return msg;
+}
+
+void ipmi_free_msg(struct ipmi_msg *msg __attribute__((unused)))
+{
+	if (msg)
+		free(msg->data);
+}
+
+void ipmi_queue_msg_sync(struct ipmi_msg *msg)
+{
+	struct ipmi_msg_ctx *ctx = container_of(msg, struct ipmi_msg_ctx, msg);
+	const struct scenario_cmd *cmd;
+
+	if (ctx->cursor->type == scenario_cmd) {
+		cmd = &ctx->cursor->c;
+	} else if (ctx->cursor->type == scenario_event_p) {
+		assert(ctx->cursor->p->type == scenario_cmd);
+		cmd = &ctx->cursor->p->c;
+	} else {
+		assert(false);
+	}
+
+	assert((msg->netfn >> 2) == 0x3a);
+	assert(msg->cmd == 0x5a);
+	assert(msg->req_size >= 2);
+
+	printf("Comparing received vs expected message\n");
+	for (ssize_t i = 0; i < msg->req_size; i++) {
+		printf("msg->data[%zd]: 0x%02x, cmd->req[%zd]: 0x%02x\n",
+		       i, msg->data[i], i, ((uint8_t *)(&cmd->req))[i]);
+	}
+	printf("\n");
+	assert(!memcmp(msg->data, &cmd->req, msg->req_size));
+	memcpy(msg->data, &cmd->resp, msg->resp_size);
+
+	msg->complete(msg);
+
+	ctx->cursor++;
+
+	/* Deliver all the scheduled SELs */
+	while (ctx->cursor->type == scenario_sel) {
+		ctx->sel.fn(ctx->cursor->s.bmc_state, ctx->sel.context);
+		ctx->cursor++;
+	}
+}
+
+int ipmi_sel_register(uint8_t oem_cmd __attribute__((unused)),
+		      void (*fn)(uint8_t data, void *context),
+		      void *context)
+{
+	ipmi_msg_ctx.sel.fn = fn;
+	ipmi_msg_ctx.sel.context = context;
+
+	return 0;
+}
+
+#include "../ipmi-hiomap.c"
+
+static const struct scenario_event hiomap_ack_call = {
+	.type = scenario_cmd,
+	.c = {
+		.req = {
+			.cmd = HIOMAP_C_ACK,
+			.seq = 1,
+			.args = {
+				[0] = HIOMAP_E_ACK_MASK,
+			},
+		},
+		.cc = IPMI_CC_NO_ERROR,
+		.resp = {
+			.cmd = HIOMAP_C_ACK,
+			.seq = 1,
+		},
+	},
+};
+
+static const struct scenario_event hiomap_get_info_call = {
+	.type = scenario_cmd,
+	.c = {
+		.req = {
+			.cmd = HIOMAP_C_GET_INFO,
+			.seq = 2,
+			.args = {
+				[0] = HIOMAP_V2,
+			},
+		},
+		.cc = IPMI_CC_NO_ERROR,
+		.resp = {
+			.cmd = HIOMAP_C_GET_INFO,
+			.seq = 2,
+			.args = {
+				[0] = HIOMAP_V2,
+				[1] = 12,
+				[2] = 8, [3] = 0,
+			},
+		},
+	},
+};
+
+static const struct scenario_event hiomap_get_flash_info_call = {
+	.type = scenario_cmd,
+	.c = {
+		.req = {
+			.cmd = HIOMAP_C_GET_FLASH_INFO,
+			.seq = 3,
+			.args = {
+			},
+		},
+		.cc = IPMI_CC_NO_ERROR,
+		.resp = {
+			.cmd = HIOMAP_C_GET_FLASH_INFO,
+			.seq = 3,
+			.args = {
+				[0] = 0x00, [1] = 0x20,
+				[2] = 0x01, [3] = 0x00,
+			},
+		},
+	},
+};
+
+static const struct scenario_event scenario_hiomap_init[] = {
+	{ .type = scenario_event_p, .p = &hiomap_ack_call, },
+	{ .type = scenario_event_p, .p = &hiomap_get_info_call, },
+	{ .type = scenario_event_p, .p = &hiomap_get_flash_info_call, },
+	{ },
+};
+
+static int test_hiomap_init(void)
+{
+	struct blocklevel_device *bl;
+
+	scenario_init(scenario_hiomap_init);
+	assert(!ipmi_hiomap_init(&bl));
+	ipmi_hiomap_exit(bl);
+
+	return 0;
+}
+
+static const struct scenario_event scenario_hiomap_event_daemon_ready[] = {
+	{ .type = scenario_event_p, .p = &hiomap_ack_call, },
+	{ .type = scenario_event_p, .p = &hiomap_get_info_call, },
+	{ .type = scenario_event_p, .p = &hiomap_get_flash_info_call, },
+	{ .type = scenario_sel, .s = { .bmc_state = 0x80 } },
+	{ },
+};
+
+static int test_hiomap_event_daemon_ready(void)
+{
+	struct blocklevel_device *bl;
+	struct ipmi_hiomap *ctx;
+	int rc;
+
+	scenario_init(scenario_hiomap_event_daemon_ready);
+	assert(!ipmi_hiomap_init(&bl));
+	ctx = container_of(bl, struct ipmi_hiomap, bl);
+	rc = ctx->bmc_state != 0x80;
+	ipmi_hiomap_exit(bl);
+
+	return rc;
+}
+
+static const struct scenario_event scenario_hiomap_event_daemon_stopped[] = {
+	{ .type = scenario_event_p, .p = &hiomap_ack_call, },
+	{ .type = scenario_event_p, .p = &hiomap_get_info_call, },
+	{ .type = scenario_event_p, .p = &hiomap_get_flash_info_call, },
+	{ .type = scenario_sel, .s = { .bmc_state = 0x80 } },
+	{ .type = scenario_sel, .s = { .bmc_state = 0x02 } },
+	{ },
+};
+
+static int test_hiomap_event_daemon_stopped(void)
+{
+	struct blocklevel_device *bl;
+	struct ipmi_hiomap *ctx;
+	int rc;
+
+	scenario_init(scenario_hiomap_event_daemon_stopped);
+	assert(!ipmi_hiomap_init(&bl));
+	ctx = container_of(bl, struct ipmi_hiomap, bl);
+	rc = ctx->bmc_state != 0x02;
+	ipmi_hiomap_exit(bl);
+
+	return rc;
+}
+
+static const struct scenario_event scenario_hiomap_event_daemon_restarted[] = {
+	{ .type = scenario_event_p, .p = &hiomap_ack_call, },
+	{ .type = scenario_event_p, .p = &hiomap_get_info_call, },
+	{ .type = scenario_event_p, .p = &hiomap_get_flash_info_call, },
+	{ .type = scenario_sel, .s = { .bmc_state = 0x80 } },
+	{ .type = scenario_sel, .s = { .bmc_state = 0x02 } },
+	{ .type = scenario_sel, .s = { .bmc_state = 0x80 } },
+	{ },
+};
+
+static int test_hiomap_event_daemon_restarted(void)
+{
+	struct blocklevel_device *bl;
+	struct ipmi_hiomap *ctx;
+	int rc;
+
+	scenario_init(scenario_hiomap_event_daemon_restarted);
+	assert(!ipmi_hiomap_init(&bl));
+	ctx = container_of(bl, struct ipmi_hiomap, bl);
+	rc = ctx->bmc_state != 0x82;
+	ipmi_hiomap_exit(bl);
+
+	return rc;
+}
+
+int main(void)
+{
+	assert(!test_hiomap_init());
+	assert(!test_hiomap_event_daemon_ready());
+	assert(!test_hiomap_event_daemon_stopped());
+	assert(!test_hiomap_event_daemon_restarted());
+
+	return 0;
+}
-- 
2.19.1

