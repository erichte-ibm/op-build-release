From 9b99b0b7b5a063e5e0897f11571027bed3324779 Mon Sep 17 00:00:00 2001
From: Douglas Gilbert <dgilbert@us.ibm.com>
Date: Tue, 22 May 2018 13:34:16 -0500
Subject: [PATCH] captureFir: Add delay and sbefifo reset

Change-Id: Ieb71ecd8a90579293a3c9875275f4add8ac0c713
Reviewed-on: http://ralgit01.raleigh.ibm.com/gerrit1/59192
Tested-by: FSP CI Jenkins <fsp-CI-jenkins+hostboot@us.ibm.com>
Reviewed-by: Brian J. Stegmiller <bjs@us.ibm.com>
Reviewed-by: Martha Broyles <mbroyles@us.ibm.com>
---
 src/occ_gpe0/firdata/fir_data_collect.c |  3 ++
 src/occ_gpe0/firdata/sbe_fifo.c         | 64 ++++++++++++++++++++++++++++++---
 src/occ_gpe0/firdata/sbe_fifo.h         |  2 ++
 3 files changed, 64 insertions(+), 5 deletions(-)

diff --git a/src/occ_gpe0/firdata/fir_data_collect.c b/src/occ_gpe0/firdata/fir_data_collect.c
index cf1de9d..63b46eb 100644
--- a/src/occ_gpe0/firdata/fir_data_collect.c
+++ b/src/occ_gpe0/firdata/fir_data_collect.c
@@ -31,6 +31,7 @@
 #include <gpe_export.h>
 
 extern gpe_shared_data_t * G_gpe_shared_data;
+extern void busy_wait(uint32_t t_microseconds);
 
 /*
  * Function Specification
@@ -54,6 +55,8 @@ void fir_data_collect(void)
     uint8_t *l_pBuf = (uint8_t*) G_gpe_shared_data->fir_heap_buffer_ptr;
     uint32_t l_pBufSize = FIR_HEAP_SECTION_SIZE;
 
+    busy_wait(2000000);  // wait two seconds
+
     l_rc = FirData_captureCsFirData(l_hBuf,
                                     l_hBufSize,
                                     l_pBuf,
diff --git a/src/occ_gpe0/firdata/sbe_fifo.c b/src/occ_gpe0/firdata/sbe_fifo.c
index 51fdf50..4f0bd2f 100644
--- a/src/occ_gpe0/firdata/sbe_fifo.c
+++ b/src/occ_gpe0/firdata/sbe_fifo.c
@@ -42,6 +42,7 @@ enum
 
     RC_FIFO_TIMEOUT_UP = 1021,
     RC_FIFO_TIMEOUT_DN = 1022,
+    RC_FIFO_TIMEOUT_RESET = 1023,
 };
 
 /** @brief  Waits for FIFO to be ready to be written to
@@ -133,6 +134,56 @@ uint32_t waitDnFifoReady(SCOM_Trgt_t* i_target, uint32_t* o_status)
     return l_rc;
 }
 
+/** @brief  Reset FIFO
+ *  @param  i_target. The SCOM target.
+ *  @return SUCCESS | returncode
+ */
+uint32_t upFifoReset(SCOM_Trgt_t* i_target)
+{
+    uint32_t l_rc = SUCCESS;
+    uint64_t l_elapsed_time_ns = 0;
+    uint32_t l_addr = SBE_FIFO_UPFIFO_REQ_RESET;
+    uint32_t l_data = 0xDEAD;
+
+    l_rc = putfsi(i_target, l_addr, l_data);
+    if(l_rc != SUCCESS)
+    {
+        TRAC_ERR("upFifoReset:putfsi failed. rc = %d",l_rc);
+    }
+    else
+    {
+        l_addr = SBE_FIFO_UPFIFO_STATUS;
+
+        do
+        {
+            l_rc = getfsi(i_target, l_addr, &l_data);
+            if(l_rc != SUCCESS)
+            {
+                break;
+            }
+
+            // Wait for bit to clear
+            if((l_data & UPFIFO_STATUS_FIFO_NOTREADY) == 0)
+            {
+                break;
+            }
+
+            if(l_elapsed_time_ns >= MAX_UP_FIFO_TIMEOUT_NS)
+            {
+                TRAC_ERR("upFifoReset: timeout waiting for upstream"
+                         " FIFO to reset.");
+                l_rc = RC_FIFO_TIMEOUT_RESET;
+                break;
+            }
+
+            busy_wait(10); // wait for 10,000 ns
+            l_elapsed_time_ns += 10000;
+
+        } while(TRUE);
+    }
+    return l_rc;
+}
+
 /** @brief  Writes a request to FIFO
  *  @param  i_target The SCOM target.
  *  @param  i_fifoRequest the request to execute.
@@ -202,7 +253,7 @@ uint32_t writeRequest(SCOM_Trgt_t* i_target, uint32_t* i_fifoRequest)
 // For error path debug.
 void printBuffer( uint32_t* i_readBuffer, uint32_t i_wordsReceived )
 {
-    // OCC traces only support max 4 arguments and trace buffers very limited.
+    // GPE traces only support max 4 arguments and trace buffers very limited.
     // So try to print as many entries as possible on one line as possible.
     uint32_t i = 0;
     for ( i = 0; i < i_wordsReceived; i+=4 )
@@ -409,8 +460,7 @@ int32_t putFifoScom(SCOM_Trgt_t* i_target, uint64_t i_addr, uint64_t i_data)
     if ( l_rc != SUCCESS )
     {
         // Reset the FIFO for subsequent SCOMs
-        uint32_t l_data = 0xDEAD;
-        putfsi( i_target, 0x2450, l_data );
+        upFifoReset(i_target);
     }
 
     return l_rc;
@@ -459,8 +509,12 @@ int32_t getFifoScom(SCOM_Trgt_t* i_target, uint64_t i_addr, uint64_t* o_data)
         if ( l_rc != SUCCESS )
         {
             // Reset the FIFO for subsequent SCOMs
-            uint32_t l_data = 0xDEAD;
-            putfsi( i_target, 0x2450, l_data );
+            uint32_t resetRc = upFifoReset(i_target);
+            if(resetRc == RC_FIFO_TIMEOUT_RESET)
+            {
+                // timeout msg already traced, Return original fail rc.
+                break;
+            }
         }
 
     } while ( TRUE );
diff --git a/src/occ_gpe0/firdata/sbe_fifo.h b/src/occ_gpe0/firdata/sbe_fifo.h
index 83d293a..7b6df51 100644
--- a/src/occ_gpe0/firdata/sbe_fifo.h
+++ b/src/occ_gpe0/firdata/sbe_fifo.h
@@ -42,7 +42,9 @@
 #define FSB_UPFIFO_SIG_EOT 0x80000000
 #define SBE_FIFO_UPFIFO_STATUS 0x00002404
 #define SBE_FIFO_DNFIFO_STATUS 0x00002444
+#define SBE_FIFO_UPFIFO_REQ_RESET 0x0000240c
 #define UPFIFO_STATUS_FIFO_FULL 0x00200000
+#define UPFIFO_STATUS_FIFO_NOTREADY 0x02000000
 #define DNFIFO_STATUS_FIFO_EMPTY 0x00100000
 #define DNFIFO_STATUS_DEQUEUED_EOT_FLAG 0x00800000
 #define SBE_FIFO_DNFIFO_ACK_EOT 0x00002454
-- 
2.16.2.windows.1

